\chapter{Assistente de provas}
\label{cap:provas}

Um assistente de provas interativo é um artifício de software que auxilia no processo de prova matemática. Diferentemente dos provadores automáticos de teoremas, os assistentes não realizam provas automaticamente com um simples comando do usuário, mas participa com ele no processo oferecendo uma variedade de procedimentos formalizadores. Seu uso também se justifica na necessidade de validar demonstrações, haja vista que detalhes podem passar despercebidos pelo olhar analítico do ser humano. Os assistentes mais robustos implementam a teoria dos tipos, na qual os elementos pertencem a tipos definidos recursivamente, e não a conjuntos.

A teoria dos tipos fornece o encontro da ciência da computação com a matemática e a lógica. Ela é simultaneamente um sistema formal e linguagem de programação que permite raciocinar enquanto se programa. Sua relevância se explica por possuir simplicidade, ser robusta, apresentar a propriedade da decidibilidade, ser uma linguagem funcional, entre outros \cite{luo}.

Há pelo menos 15 provadores de teoremas no mundo, entre os quais estão os provadores semiautomáticos, ou assistentes de provas. Os assistentes mais utilizados são: HOL, Mizar, PVS, Coq, Isabelle, Agda, Phox, IMPS, Metamath, Lego, NuPRL e Omega-MEGA. Em relação aos sistemas de tipos, o Metamath não é tipado; o HOL, Isabelle, Phox, IMPS e Omega-MEGA permitem apenas tipos não dependentes decidíveis; o PVS e NuPRL, tipos dependentes indecidíveis; os demais, tipos dependentes decidíveis. Apenas o Coq e o NuPRL têm lógica de ordem superior. O Metamath destaca-se por sua lógica quântica, enquanto os demais empregam lógica clássica ou construtivista. Em geral, se um assistente é capaz de verificar a prova de um teorema, seu emprego é válido. A escolha do provador, portanto, baseia-se na subjetividade e no relativo conforto do usuário.

A Seção \ref{sec:coq} introduz o assistente de provas empregado neste trabalho de conclusão de curso. A escolha do Coq se deve à confiabilidade, utilidade, usabilidade e facilidade desse assistente.

\section{Coq}
\label{sec:coq}

Coq é um dos assistentes de provas mais utilizados atualmente, permitindo a construção de tipos dependentes e polimórficos, lógica de ordem superior, etc. A linguagem formal deste assistente de provas é o cálculo de construções indutivas (\acs{CCI}), no qual há duas variedades de objetos, os tipos e os termos. Os tipos são classes a que pertencem os termos -- o número $1$ é um termo do tipo natural -- e podem ser termos de outros tipos. Nessa linguagem formal, a notação para um termo $x$ do tipo $X$ é $x:X$, com a qual se deve habituar para utilizar o Coq \cite{manualcoq}.

No Coq os tipos são definidos indutivamente pelos comandos \texttt{Inductive}, \texttt{Fixpoint} e \texttt{Record}. O primeiro permite definir termos destarte: \begin{align*}
&\texttt{Inductive $ident$ : $term$ :=}\\ &\texttt{$ident_1$ : $term_1$ | $ident_2$ : $term_2$ | $...$ | $ident_n$ : $term_n$.}
\end{align*} em que $ident$ é o nome do objeto sendo definido e $term$ é seu tipo. Cada $ident_i$ e $term_i$ são os respectivos nome e tipo do $i$-ésimo construtor ($\forall i=1..n$). O comando \texttt{Fixpoint} define funções de forma recursiva baseada nos $m$ argumentos: \begin{align*}
&\texttt{Fixpoint $ident$ ($ident_1$ : $term_1$) ($ident_1$ : $term_1$) $...$ ($ident_m$ : $term_m$)}\\&\texttt{: $term$ := $term'$.}
\end{align*} A definição usando esse comando deve garantir que a recursão sempre para. Para tanto, o usuário precisa especificar a recursão mediante a estrutura \texttt{match with}: \begin{align*}
term' := \text{} & \texttt{match $ident_1$, $ident_2$, $...$, $ident_m$ with}\\
& \texttt{$a_1^1$, $a_2^1$, $...$, $a_m^1$ => $term_1'$ |}\\
& \texttt{$a_1^2$, $a_2^2$, $...$, $a_m^2$ => $term_2'$ |}\\
& \vdots\\
& \texttt{$a_1^k$, $a_2^k$, $...$, $a_m^k$ => $term_k'$}\\
& \texttt{end}
\end{align*} gerando uma análise de caso para o valor de cada $ident_i$. Assim, se $\langle ident_1, ident_2, \allowbreak ..., ident_m \rangle$ é $\langle a_1^j, a_2^j, ..., a_m^j \rangle$, o retorno da função é $term_j'$ ($\forall i = 1..m, j = 1..k$). Quando não é necessário haver recursão, pode-se substituir o comando pelo \texttt{Definition}. Já o comando \texttt{Record} aproxima o usuário das linguagens de programação comuns, ao definir estruturas parecidas com as quais se desenvolve nelas: \begin{align*}
&\texttt{Record $ident$ $params$ : $term$ := $ident_0$ \{}\\
&\texttt{$ident_1$ : $term_1$;}\\
&\texttt{$ident_2$ : $term_2$;}\\
&\vdots\\
&\texttt{$ident_n$ : $term_n$ \}.}
\end{align*} em que $params$, $ident_0$, $ident_i$ e $term_i$ são, respectivamente, os parâmetros ou argumentos, nome do construtor (opcional), nome e tipo do $i$-ésimo campo ($\forall i = 1..n$), havendo $n$ campos. Na linguagem do Coq, o $i$-ésimo campo de um \textit{record} é obtido com esta sintaxe: \texttt{$ident_i$ $x$}, em que $x : ident$. Há outras maneiras de definir termos a partir desses comandos, mas as apresentadas são suficientes para os objetivos do presente trabalho.

A sintaxe exposta é a combinação do CCI com a linguagem de especificação Gallina, bastante intuitivos. Para provar teoremas e lemas no Coq, além de definir os tipos que serão usados nas proposições, é necessário utilizar o comando \texttt{Theorem} ou \texttt{Lemma}: $$\texttt{Theorem $ident$ := $ident'$. Proof. $tactic_1$. $tactic_2$. $...$. $tactic_m$. Qed.}$$ com $m$ táticas. As táticas são o cerne da interatividade do Coq e facilitam o desenvolvimento de provas. Elas implementam um raciocínio que parte da conclusão para as premissas, denominadas objetivo e subobjetivos respectivamente. Uma tática, aplicada corretamente sobre o objeto, gera subobjetivos que o substituem \cite{manualcoq}. O Quadro \ref{quad:taticas_coq} apresenta as principais táticas do Coq utilizadas por este trabalho.

\novoquadro{Principais táticas do Coq}{
	\begin{tabular}{|c|c|}
		\hline \textbf{Nome} & \textbf{Descrição}\\ \hline
		\texttt{intros} & Introduz variáveis\\ \hline
		\texttt{simpl} & Simplifica expressão\\ \hline
		\texttt{reflexivity} & Valida expressões $a = a$\\ \hline
		\texttt{rewrite} & Reescreve relações de igualdade\\ \hline
		\texttt{apply} & Aplica um lema, teorema ou axioma\\ \hline
		\texttt{symmetry} & Troca $a = b$ por $b = a$\\ \hline
		\texttt{injection} & Infere $a = b$ a partir de $f(a) = f(b)$, sendo $f$ injetora\\ \hline
		\multirow{2}{*}{\texttt{omega}} & Completa prova a partir de igualdades e\\
		& desigualdades envolvendo inteiros\\ \hline
		\texttt{induction} & Faz indução sobre uma variável\\ \hline
	\end{tabular}
}{quad:taticas_coq}{Elaborado pelo autor com base em \citeonline{manualcoq}, 2019}

Outras táticas importantes são: \texttt{unfold} -- para expandir expressões reduzidas --, \texttt{discriminate} -- usada quando existe uma igualdade falsa no contexto, como $1 = 0$ -- e \texttt{inversion}. Esta última faz o Coq analisar outras condições para que uma hipótese seja verdadeira. A fim de exemplificar o uso das táticas do Coq, é provado o teorema $$\texttt{Theorem plus\_n\_O : $\forall$ n : nat, n = n + 0.}$$ em que $nat$ é o tipo dos números naturais. Começa-se removendo o quantificador universal e introduzindo a variável \texttt{n}: $$\texttt{Proof. intros n.}$$ Agora, inicia-se a indução sobre \texttt{n}: $$\texttt{induction n as [|n' IHn'].}$$ em que os símbolos após o ``\texttt{|}'' nomeiam as variáveis a serem utilizadas no passo indutivo. Para a base $\texttt{n} = \texttt{0}$, basta simplificar e aplicar a tática \texttt{reflexivity}. Como esta já simplifica a expressão, não é necessário aplicar \texttt{simpl}. No passo indutivo, tem-se $\texttt{n} = \texttt{S n'}$, sendo \texttt{S x} a função sucessor de $\texttt{x} : \texttt{nat}$. O objetivo atual é $$\texttt{S n' = S n' + 0}$$ Simplificando com \texttt{simpl}, obtém-se $$\texttt{S n' = S (n' + 0)}$$ Agora se pode aplicar a hipótese de indução $\texttt{IHn'} = \texttt{(n' = n' + 0)}$ mediante a tática $$\texttt{rewrite <- IHn'.}$$ com \texttt{<-} indicando que o lado direito da hipótese \texttt{IHn'} deve ser reescrito pelo esquerdo no objetivo, o que gera $$\texttt{S n' = S n'}$$ Por fim, $$\texttt{reflexivity. Qed.}$$ como se queria demonstrar.

O capítulo seguinte, \ref{cap:seds}, conceitua os sistemas a eventos discretos e autômatos finitos determinísticos, objetos das demonstrações do Capítulo \ref{cap:propriedades}. Essas provas foram obtidas e validadas no ambiente do assistente Coq.