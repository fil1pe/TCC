Require Import Coq.Lists.List Coq.Bool.Bool Omega Utils.
Import ListNotations.

Module Type DFA.
  Parameters
    (A B : Type)
        (* Types of the states and events *)
    (states : list A)
    (events : list B)
    (transition : A -> B -> A)    (* transition function *)
    (state0 : A)    (* initial state *)
    (sink : A)    (* sink state *)
    (marked_states : list A)
    (transition_correct : forall q e, transition q e <> sink -> In e events /\ In q states /\ q <> sink /\ In (transition q e) states)
        (* Given elements q and e, a proper transition(q,e)=q' can exist if q is a proper state, e is a proper event,
          and q' is a proper state or the sink one. *)
    (state0_correct : In state0 states)
        (* The initial state must be in the list of states. *)
    (marked_states_correct : forall q, In q marked_states -> In q states)
        (* Every marked state too. *)
    (sink_correct : In sink states /\ sink <> state0 /\ ~ In sink marked_states)
        (* The sink state must be in the list of states, differ from the initial one and not be in the list of marked states. *)
    (A_eq_dec : forall x y : A, {x = y} + {x <> y})
    (B_eq_dec : forall x y : B, {x = y} + {x <> y})
        (* Decidable equality of A and B is important for computation. *)
    .
End DFA.

Module DFAUtils (G:DFA).

Include G.

(* The list of states is never empty, as there is at least the initial and the sink one. *)
Lemma states_not_nil : states <> nil.
Proof.
  pose proof state0_correct as H;
  intro contra; rewrite contra in H;
  pose proof in_nil; contradiction.
Qed.

(*
  The extended transition function, applying the transition function through a given sequence of (possible) events
 starting from a given (possible) state.
*)
Fixpoint xtransition q w :=
  match w with
  | e::w' => xtransition (transition q e) w'
  | nil => q
  end.

(* The extended transition function is pseudo-distributive, meaning that transitioning through w1++w2 is equal to
  first transitioning through w1 and then w2. *)
Theorem xtransition_distr w1 w2 : forall q,
  xtransition q (w1 ++ w2) = xtransition (xtransition q w1) w2.
Proof.
  induction w1 as [|e w1' IH]; try (intro q; simpl; rewrite IH); trivial.
Qed.

(* Any extended transition starting from the sink state ends in it. *)
Lemma xtransition_sink w :
  xtransition sink w = sink.
Proof.
  induction w as [|e w IH].
  - intuition.
  - simpl.
    destruct (A_eq_dec (transition sink e) sink) as [H|H].
    + rewrite H; intuition.
    + apply transition_correct in H; destruct H as [H [H0 [H1 H2]]]; contradiction.
Qed.

(* transition function from the initial state *)
Definition ixtransition w := xtransition state0 w.

(* ixtransition is obviously pseudo-distributive, as xtransition is. *)
Theorem ixtransition_distr w1 w2 :
  ixtransition (w1 ++ w2) = xtransition (ixtransition w1) w2.
Proof. apply xtransition_distr. Qed.

(* Any sequence of events transitions into a proper state or the sink one. *)
Lemma ixtransition_in_states w :
  In (ixtransition w) states.
Proof.
  pose proof state0_correct;
  unfold ixtransition;
  generalize dependent state0;
  induction w as [|e w' IH]; intros q H0.
  - intuition.
  - apply IH; destruct (A_eq_dec (transition q e) sink) as [H1|H1].
    + rewrite H1; pose proof sink_correct; intuition.
    + apply transition_correct in H1; intuition.
Qed.

(* A DFA generates a sequence of events (string) w if transitioning from the initial state through w results in
  a proper state. *)
Definition generates w := ixtransition w <> sink.

(* A DFA marks a sequence of events w if transitioning from the initial state through w results in
  a marked state. *)
Definition marks w := In (ixtransition w) marked_states.

(* The language generated by any DFA G, { w | G generates w }, is prefix-closed.
   Any prefix of any generated sequence of events is also generated by the same DFA,
  as it must transition through the prefix before finishing the transition through the
  entire sequence. *)
Theorem gen_prefix_closed : forall w1 w2,
  generates (w1 ++ w2) -> generates w1.
Proof.
  unfold generates;
  intros w1 w2 H contra;
  rewrite ixtransition_distr, contra, xtransition_sink in H;
  contradiction.
Qed.

(* A state q is tangible if it is not the sink one and there is at least one sequence of events
  through which ixtransition leads to q. *)
Definition is_tangible q := q <> sink /\ exists w, ixtransition w = q.

(*
  config is a function that lists the states a transition through a sequence of events starting from the
 initial state results in.
*)
Fixpoint config' q w :=
  match w with
  | e::w' => (transition q e)::config' (transition q e) w'
  | nil => []
  end.
Definition config w := state0::config' state0 w.

(* Every element in config w must be in the list of states. *)
Lemma config_states_correct w : forall q,
  In q (config w) -> In q states.
Proof.
  unfold config; intros q H; destruct H.
  - rewrite <- H; apply state0_correct.
  - generalize dependent state0;
    induction w as [|e w IH]; intros a H; destruct H.
    + destruct (A_eq_dec q sink) as [H0|H0].
      * rewrite H0; apply sink_correct.
      * rewrite <- H in H0; apply transition_correct in H0;
        rewrite <- H; intuition.
    + eapply IH; apply H.
Qed.

(* str_pow w n, or w^n, is equal to w1 ++ w2 ++ ... ++ wn
  where w1 = w2 = ... = wn = w. *)
Fixpoint str_pow (w:list B) (n:nat) :=
  match n with
  | O => []
  | S n' => w ++ (str_pow w n')
  end.
Notation "w ^ n" := (str_pow w n).

(* If transitioning through w leads to the initial state, then, for all n, w^n leads to it too. *)
Lemma state0_cycle: forall w n,
  ixtransition w = state0 -> ixtransition (w^n) = state0.
Proof.
  intros w n H;
  induction n as [|n IH]. auto.
  unfold ixtransition in *;
  simpl;
  rewrite xtransition_distr, H;
  auto.
Qed.

(*
  If w is a sequence of n events, then transitioning through w goes through n states.
  Thus, config w is a list of n+1 states.
*)
Lemma config'_length w : forall q,
  length (config' q w) = length w.
Proof.
  induction w as [|e w' IH];
  try (intro q; simpl; rewrite IH); trivial.
Qed.
Lemma config_length w :
  length (config w) = S (length w).
Proof.
  simpl; rewrite config'_length; trivial.
Qed.

Section Pigeonhole.

(* a inductive proposition for element repetition in list *)
Inductive repeats {X} : list X -> Prop :=
  | r_constr l a : In a l \/ repeats l -> repeats (a::l).

(* If a is in l, then l = l1 ++ [a] ++ l2 for some l1 and l2. *)
Lemma In_existence : forall {X} a (l:list X),
  In a l -> exists l1 l2, l = l1 ++ [a] ++ l2.
Proof.
  intros X a l H;
  induction l as [|b l IH]; destruct H.
  - clear IH; exists nil, l; rewrite H; auto.
  - apply IH in H; clear IH; destruct H as [l1 [l2 H]];
    exists (b::l1), l2; rewrite H; auto.
Qed.

(* If l repeats element, l can be written as some l1 ++ [a] ++ l2 ++ [q] ++ l3. *)
Lemma repeats_existence {X} (l:list X) :
  repeats l ->
  exists a l1 l2 l3, l = l1 ++ [a] ++ l2 ++ [a] ++ l3.
Proof.
  intro H;
  induction l as [|b l IH]; inversion H.
  destruct H1.
  - apply In_existence in H1; destruct H1 as [l1 [l2 H1]];
    exists b, nil, l1, l2; rewrite H1; auto.
  - apply IH in H1; destruct H1 as [c [l1 [l2 [l3 H1]]]];
    exists c, (b::l1), l2, l3; rewrite H1; auto.
Qed.

(* Let n be the number of possible states.
   As the pigeonhole principle states, if config w has at least n+1 states, then
  config w repeats state. *)
Lemma config_pigeonhole w : 
  length (config w) > length states ->
  repeats (config w).
Proof.
  intro H;
  pose proof (config_states_correct w) as H0;
  generalize dependent (config w);
  generalize dependent states;
  clear w;
  intros l2 l1; revert l2; induction l1 as [|x1 l1 IH]; intros l2 H H0.
  - simpl in H; omega.
  - destruct l2 as [|x2 l2].
    specialize (H0 x1); assert (H1: In x1 (x1 :: l1)). left; trivial.
    apply H0 in H1; destruct H1.

    destruct (in_dec (A_eq_dec) x1 l1) as [H1|H1].
    constructor; intuition.
    assert (H2: In x1 (x2::l2)).
      apply H0; left; trivial.
    apply in_split in H2. destruct H2 as [l2' [l2'' H2]].
    assert (H3: length l2 = length (l2' ++ l2'')). {
      rewrite app_length.
      assert (H4: length ([x2] ++ l2) = length (l2' ++ [x1] ++ l2'')).
        simpl ([x2] ++ l2); rewrite H2; intuition.
      rewrite app_length, app_length, app_length in H4;
      simpl in H4; omega.
    }
    assert (forall x, In x l1 -> In x (l2'++l2'')). {
      clear IH H H3; intros x H; rewrite H2 in H0;
      assert (H3: In x (l2' ++ x1 :: l2'')). apply H0; right; auto.
      clear H0 H2.
      induction l2' as [|x2' l2' IH].
      - simpl; simpl in H3; destruct H3 as [H3|H3].
        rewrite <- H3 in H; contradiction.
        auto.
      - destruct H3 as [H3|H3].
        left; auto.
        right; apply IH; trivial.
    }
    constructor; right; eapply IH.
    2: apply H4.
    simpl in H; omega.
Qed.

End Pigeonhole.

Section PumpingLemma.

(*
  The following lemmas help prove the Pumping Lemma.
*)

Lemma config_2concat w : forall q0 a b,
  a <> nil -> q0::config' q0 w = a ++ b ->
  exists w1 w2,
    w = w1 ++ w2 /\
    xtransition q0 w1 = last a q0 /\
    xtransition (last a q0) w2 = last b (last a q0).
Proof.
  induction w as [|e w IH]; intros q0 a b H H0;
  simpl in H0.
  - assert (H1: b = []). {
      destruct a, b; try contradiction; auto.
      simpl in H0. assert (contra: length ([q0]) = length (a :: a0 ++ a1 :: b)).
                     rewrite H0; auto.
      simpl in contra; rewrite app_length in contra; simpl in contra; omega.
    }
    exists nil, nil; repeat split.
    + rewrite H1 in H0; rewrite app_nil_r in H0;
      rewrite <- H0; auto.
    + rewrite H1; simpl; auto.
  - destruct a as [|a0 a]. contradiction.
    assert (H2: transition q0 e :: config' (transition q0 e) w =
      a ++ b).
      simpl in H0; inversion H0; auto.
    destruct a as [|a1 a].
    + simpl in *. destruct b as [|b0 b]. discriminate.
      assert (H3: config' (transition q0 e) w = b).
        inversion H2; auto.
      destruct b as [|b1 b].
      * simpl in H3. destruct w as [|e' w].
        2: simpl in H3; discriminate.
        clear H2 H3. simpl in H0.
        exists nil, [e]; repeat split.
        -- inversion H0; auto.
        -- simpl; inversion H0; auto.
      * exists nil. replace (b0 :: b1 :: b) with ([b0;b1] ++ b) in H2.
        apply IH in H2.
        destruct H2 as [w1 [w2 [H2 [H5 H4]]]].
        exists (e::w1 ++ w2); repeat split.
        -- simpl; rewrite H2; auto.
        -- inversion H0; auto.
        -- simpl (xtransition a0 (e :: w1 ++ w2));
           rewrite xtransition_distr; inversion H0;
           rewrite <- H6, H5, H4, H3; simpl;
           clear; induction b as [|b0 b IH]; try (destruct b); auto.
        -- intro contra; discriminate.
        -- auto.
    + apply IH in H2;
      destruct H2 as [w1 [w2 [H2 [H5 H4]]]].
      2: intro contra; discriminate.
      assert (aux: last (a1 :: a) (transition q0 e) = last (a0 :: a1 :: a) q0).
        simpl; clear; induction a as [|a0 a IH]; try (destruct a); auto.
      exists (e::w1), w2; repeat split.
      * simpl; rewrite H2; auto.
      * simpl (xtransition q0 (e :: w1)); rewrite H5; apply aux.
      * rewrite <- aux; auto.
Qed.

Lemma config_3concat w : forall q0 a b c,
  a <> nil -> b <> nil -> q0::config' q0 w = a ++ b ++ c ->
  exists w1 w2 w3,
    w = w1 ++ w2 ++ w3 /\
    xtransition q0 w1 = last a q0 /\
    xtransition (last a q0) w2 = last b q0 /\
    xtransition (last b q0) w3 = last c (last b q0) /\
    w2 <> nil.
Proof.
  induction w as [|e w IH]; intros q0 a b c H H0 H1;
  simpl in H1.
  - destruct a, b; try contradiction.
    simpl in H1. assert (contra: length ([q0]) = length (a :: a0 ++ a1 :: b ++ c)).
                   rewrite H1; auto.
    simpl in contra; rewrite app_length in contra; simpl in contra; omega.
  - destruct a as [|a0 a]. contradiction.
    assert (H2: transition q0 e :: config' (transition q0 e) w =
      a ++ b ++ c).
      simpl in H1; inversion H1; auto.
    destruct a as [|a1 a].
    + simpl in H2; clear IH H; exists nil;
      apply config_2concat in H2; simpl.
      destruct H2 as [w1 [w2 [H2 [H3 H4]]]].
      exists (e::w1), w2; repeat split.
      * simpl; rewrite H2; auto.
      * inversion H1; auto.
      * simpl; inversion H1; rewrite <- H5, H3;
        apply last_any_default; auto.
      * replace (last b q0) with (last b (transition q0 e)).
        auto. apply last_any_default; auto.
      * intro contra; discriminate.
      * auto.
    + clear H1. apply IH in H2.
      destruct H2 as [w1 [w2 [w3 [H3 [H4 [H5 [H6 H7]]]]]]].
      assert (aux1: forall t1 t2, last (a1 :: a) t1 = last (a1 :: a) t2).
        intros t1 t2; apply last_any_default; intro contra; discriminate.
      assert (aux2: forall t1 t2, last b t1 = last b t2).
        intros t1 t2; apply last_any_default; auto.
      exists (e::w1), w2, w3. repeat split; auto.
      * simpl; rewrite H3; auto.
      * simpl (xtransition q0 (e :: w1)); rewrite H4.
        replace (last (a0 :: a1 :: a) q0) with (last (a1::a) q0). 2: auto.
        apply aux1.
      * replace (last (a0 :: a1 :: a) q0) with (last (a1::a) q0). 2: auto.
        replace (last (a1 :: a) q0) with (last (a1 :: a) (transition q0 e)). 2: apply aux1.
        rewrite H5; apply aux2.
      * replace (last b q0) with (last b (transition q0 e)). 2: apply aux2.
        apply H6.
      * intro contra; discriminate.
      * auto.
Qed.

Lemma repeats_skip_in_transition w :
  length w >= length states ->
  exists w1 w2 w3,
    w = w1 ++ w2 ++ w3 /\ w2 <> [] /\
    ixtransition (w1 ++ w3) = ixtransition w /\
    ixtransition (w1 ++ w2) = ixtransition w1.
Proof.
  intro H0;
  assert (H: length (config w) > length states). rewrite config_length; omega.
  clear H0; apply config_pigeonhole, repeats_existence in H;
  assert (H10: forall (l:list A) o, l ++ [o] <> []).
    intros l o contra; destruct l; discriminate.
  unfold config in H;
  unfold config, ixtransition;
  generalize dependent state0; intros q0 H;
  destruct H as [q [c1 [c2 [c3 H]]]];
  rewrite (app_assoc c1), (app_assoc c2) in H;
  pose H as H0.
  assert (H6: forall c q', last (c ++ [q]) q' = q). {
    clear H10 H0 H w q0 c1 c2 c3;
    induction c as [|x c IH]; simpl.
    auto.
    destruct (c ++ [q]) eqn:H.
    + destruct c; discriminate.
    + auto.
  }
  apply config_3concat in H0;
  destruct H0 as [w1 [w2 [w3 [H0 [H1 [H2 [H3 H4]]]]]]];
  assert (H5: last (c1 ++ [q]) q0 = last (c2 ++ [q]) q0). {
    clear H H0 H1 H2 H3 H4 H6;
    induction c2 as [|c c2 IH]; simpl.
    - induction c1 as [|c c1 IH]; auto.
      simpl; destruct (c1 ++ [q]) eqn:H.
      apply H10 in H; destruct H.
      auto.
    - simpl; destruct (c2 ++ [q]) eqn:H.
      apply H10 in H; destruct H.
      auto.
  }
  exists w1, w2, w3; repeat split; auto.
  rewrite H0, xtransition_distr, xtransition_distr, xtransition_distr,
    H1, H2, H5; auto.
  rewrite xtransition_distr, H1, H2, H5; auto.
  2,4: apply H10.
  1,2: rewrite H6, H6; auto.
Qed.

(* a generalized pumping lemma *)
Lemma pumping w :
  length w >= length states ->
  exists w1 w2 w3,
    w = w1 ++ w2 ++ w3 /\
    w2 <> [] /\
    length (w1 ++ w2) <= length states /\
    forall n, ixtransition (w1 ++ w2^n ++ w3) = ixtransition w.
Proof.
  intro H;
  induction w as [|e w IH] using @rev_ind.
  - simpl in H;
    assert (length states > 0).
      assert (H0: length states = 0). omega.
      clear H;
      rewrite length_zero_iff_nil in H0;
      pose proof state0_correct as H; rewrite H0 in H;
      inversion H.
    omega.
  - pose H as H10; rewrite app_length in H10; simpl in H10; inversion H10.
    + clear IH; pose H as H20; apply repeats_skip_in_transition in H20;
      destruct H20 as [w1 [w2 [w3 [H20 [H0 [H2 H3]]]]]].

      exists w1, w2, w3; repeat split.
      1,2:  auto.
      2:    intro n; induction n as [|n IH];
      simpl; try (rewrite app_assoc, app_assoc, <- app_assoc, ixtransition_distr, H3,
          <- ixtransition_distr); auto.
      assert (length states = length w1 + length w2 + length w3).
        rewrite <- app_length, <- app_length, <- app_assoc, <- H20, app_length; auto.
      rewrite app_length; omega.
    + assert (H2: length w >= length states). omega.
      clear H10 H1 H0 H m;
      apply IH in H2; clear IH;
      destruct H2 as [w1 [w2 [w3 [H2 [H3 [H4 H5]]]]]];
      exists w1, w2, (w3 ++ [e]); repeat split.
      1:    rewrite H2, <- app_assoc, <- app_assoc; auto.
      1,2:  auto.
      intro n;
      replace (w1 ++ str_pow w2 n ++ w3 ++ [e]) with ((w1 ++ w2^n ++ w3) ++ [e]).
      rewrite ixtransition_distr, H5, <- ixtransition_distr; auto.
      repeat (rewrite app_assoc); auto.
Qed.

(*
  Pumping Lemma for regular languages:
  --
  If L is a regular language, then there is a DFA G whose marked language is L.
  There exists p (pumping length) such that every string w of L with length at least p
 can be written as some w1 ++ w2 ++ w3 satisfying:
  -> length w1 >= 1
  -> length (w1 ++ w2) <= p
  -> forall n, w1 ++ w2^n ++ w3 is marked
*)
Theorem reg_pumping :
  exists p,
    forall w, marks w -> length w >= p ->
      exists w1 w2 w3,  w = w1 ++ w2 ++ w3 /\
                        length w2 >= 1 /\
                        length (w1 ++ w2) <= p /\
                        forall n, marks (w1 ++ w2^n ++ w3).
Proof.
  exists (length states);
  intro w;
  unfold marks;
  intros H H0;
  apply pumping in H0;
  destruct H0 as [w1 [w2 [w3 [H0 [H1 [H2 H3]]]]]];
  exists w1, w2, w3; repeat split.
  1,3: auto.
  apply length_not_nil in H1; auto.
  intro n; rewrite (H3 n); auto.
Qed.

End PumpingLemma.

(* Let w be any sequence of (possible) events of length greater than the number of states,
  exists w' such that ixtransition w' = ixtransition w and length w' is less than the number
  of states. *)
Lemma pumping0 w :
  length w >= length states ->
  exists w', ixtransition w' = ixtransition w /\ length w' < length states.
Proof.
  remember (length w) as n eqn:H.
  generalize dependent w.
  induction n as [|n IH]; intros w H H0.
  - assert (H1: length states = 0). omega.
    apply length_zero_iff_nil in H1;
    pose proof states_not_nil; contradiction.
  - destruct w as [|e w' L] using @rev_ind; simpl in H. omega.
    clear L;
    rewrite app_length in H; simpl in H; rewrite Nat.add_1_r in H;
    injection H; intro H1.
    pose proof (Nat.leb_spec0 (length states) n) as H2.
    destruct (length states <=? n); inversion H2; clear H2.
    + apply IH in H1. 2: omega.
      destruct H1 as [w1 H1].
      pose proof (Nat.ltb_spec0 (length (w1 ++ [e])) (length states)) as H4.
      destruct (length (w1 ++ [e]) <? length states); inversion H4; clear H4.
      * exists (w1 ++ [e]); repeat split.
        destruct H1 as [H1 _]; rewrite ixtransition_distr, H1, <- ixtransition_distr; trivial.
        auto.
      * assert (H4: length (w1 ++ [e]) = length states).
        apply not_lt in H2; rewrite app_length in H2; simpl in H2;
        rewrite app_length; simpl; omega. clear H2.
        assert (H5: length (w1 ++ [e]) >= length states). omega.
        apply repeats_skip_in_transition in H5; destruct H5 as [w1' [w2' [w3' [H5 [H6 H7]]]]].
        exists (w1' ++ w3'). repeat split.
        destruct H7 as [H7 _];
        destruct H1 as [H1 _]; rewrite H7, ixtransition_distr, H1,
          <- ixtransition_distr; trivial.
        assert (H8: length (w1 ++ [e]) = length (w1' ++ w2' ++ w3')). rewrite H5; trivial.
        rewrite H4, app_length, app_length in H8; rewrite app_length.
        assert (length w2' > 0). destruct w2'. contradiction. simpl; omega.
        omega.
    + apply not_le in H3; rewrite H1 in *; clear H1 IH.
      pose proof (Nat.ltb_spec0 (length (w' ++ [e])) (length states)) as H4.
      destruct (length (w'++[e]) <? length states); inversion H4; clear H4.
      * exists (w' ++ [e]); repeat split; try (rewrite app_nil_r); trivial.
      * apply not_lt in H1; rewrite app_length in H1; simpl in H1.
        assert (length w' + 1 = length states). omega.
        assert (length (w' ++ [e]) >= length states). rewrite app_length; simpl; omega.
        apply repeats_skip_in_transition in H4; destruct H4 as [w1' [w2' [w3' [H5 [H6 H7]]]]].
        exists (w1' ++ w3'); repeat split.
        intuition.
        assert (H8: length (w' ++ [e]) = length (w1' ++ w2' ++ w3')). rewrite H5; trivial.
        rewrite app_length, app_length, app_length in H8; simpl in H8; rewrite app_length.
        assert (length w2' > 0). destruct w2'. contradiction. simpl; omega.
        omega.
Qed.

(* If a given state q is tangible, then exists w such that length w is less than the
  number of states and q is tangible through w. *)
Lemma tangible_length q :
  is_tangible q <-> exists w, ixtransition w = q /\ length w < length states
  /\ q <> sink.
Proof.
  split; intro H; destruct H as [H [w H0]].
  2: split; try (exists w); intuition.
  pose proof (Nat.leb_spec0 (length states) (length w)) as H1;
  destruct (length states <=? length w); inversion H1; clear H1.
  - assert (H3: length w >= length states). omega.
    apply pumping0 in H3; destruct H3 as [w1 H3];
    rewrite <- H0; exists (w1); rewrite <- H0 in H; intuition.
  - apply not_le in H2.
    exists w; split; try split; intuition; omega.
  - exists H; intuition.
Qed.

(*
  all_words n returns all the sequences of events of length n.
*)
Fixpoint all_words'' (l:list (list B)) e :=
  match l with
  | w::l' => [w ++ [e]] ++ all_words'' l' e
  | nil => nil
  end.
Fixpoint all_words' l E :=
  match E with
  | e::E' => all_words'' l e ++ all_words' l E'
  | nil => nil
  end.
Fixpoint all_words1 (E:list B) :=
  match E with
  | e::E' => [[e]] ++ all_words1 E'
  | nil => nil
  end.
Fixpoint all_words (n:nat) :=
  match n with
  | 1 => all_words1 events
  | O => [[]]
  | S n' => all_words' (all_words n') events
  end.

(* This lemma helps prove all_words_generated. *)
Lemma all_words_generated1 n : forall w e,
  In w (all_words n) -> In e events -> In (w++[e]) (all_words (S n)).
Proof.
  intros; simpl;
  destruct n.
  - destruct H.
    2: destruct H.
    rewrite <- H; simpl;
    induction events as [|e0 E IH].
    + inversion H0.
    + simpl; inversion H0.
      * left; rewrite H1; auto.
      * right; apply IH; auto.
  - Arguments all_words : simpl never.
    induction events as [|e0 E IH].
    inversion H0.
    simpl; apply in_or_app; inversion H0.
    + left; rewrite H1; simpl; clear IH;
      induction (all_words (S n)) as [|w0 l IH].
      * inversion H.
      * simpl; inversion H.
        -- left; rewrite H2; auto.
        -- right; apply IH; auto.
    + right; apply IH; intuition.
Qed.

(* all_words n has every generated string of length n. *)
Lemma all_words_generated n : forall w,
  generates w -> length w = n -> In w (all_words n).
Proof.
  intros w H.
  generalize dependent n.
  induction w as [|e w' IH] using @rev_ind; intros n H0.
  - simpl in H0; rewrite <- H0; simpl; left; trivial.
  - destruct n.
    + rewrite app_length in H0; simpl in H0; omega.
    + apply all_words_generated1; try (apply IH).
      * eapply gen_prefix_closed; apply H.
      * rewrite app_length in H0; simpl in H0; omega.
      * unfold generates, ixtransition in H; clear IH H0;
        generalize dependent state0;
        induction w' as [|e0 w' IH]; intros q H; simpl in H.
        -- apply transition_correct in H; intuition.
        -- eapply IH; apply H.
Qed.

(* all_words_le returns all the strings of length less or equal to n. *)
Fixpoint all_words_le (n:nat) :=
  match n with
  | S n' => all_words (S n') ++ all_words_le n'
  | O => [nil]
  end.

Lemma all_words_le_generated n : forall w,
  generates w -> length w <= n -> In w (all_words_le n).
Proof.
  intros w H H0.
  induction n as [|n' IH].
  - left; symmetry; apply length_zero_iff_nil; omega.
  - Arguments all_words : simpl never.
    simpl; apply in_or_app;
    inversion H0.
    + left; apply all_words_generated; intuition.
    + right; apply IH; intuition.
Qed.

Section TangibleDecidable.

(* Here we will prove that we can decide whether a given state is tangible. *)

(* verify_tangible q verifies if q is tangible based on the list gathering all the generated sequences of events
  of length less than the number of states. *)
Fixpoint verify_tangible' q l :=
  match l with
  | a::l' => ixtransition a = q \/ verify_tangible' q l'
  | nil => False
  end.
Definition verify_tangible q := q <> sink /\ verify_tangible' q (all_words_le (length states - 1)).

(* For every tangible state q, verify_tangible q must be True, and vice-versa. *)
Lemma verify_tangible_correct : forall q,
  is_tangible q <-> verify_tangible q.
Proof.
  split.
  + intro H; apply tangible_length in H; destruct H as [w [H [H1 H2]]].
    assert (H0: length w <= length states - 1). omega.
    apply all_words_le_generated in H0.
    2: unfold generates; rewrite H; intuition.
    unfold verify_tangible;
    induction (all_words_le (length states - 1)) as [|a l' IH].
    - pose proof in_nil; contradiction.
    - inversion H0; split.
      1,3: intuition.
      * left; rewrite H3; intuition.
      * right; intuition.
  + intros [H H0];
    unfold verify_tangible in H;
    induction (all_words_le (length states - 1)) as [|a l' IH];
    destruct H0; split.
    1,3: intuition.
    - exists a; intuition.
    - apply IH in H0; destruct H0 as [H0 [w H1]]; exists w;
      intuition.
Qed.

(* From the decidable equality of A, we can prove that, for all q, verify_tangible q is decidable. *)
Lemma verify_tangible_dec : forall q,
  {verify_tangible q} + {~ verify_tangible q}.
Proof.
  intros q; unfold verify_tangible;
  induction (all_words_le (length states - 1)) as [|a l' IH].
  - simpl; right; unfold not; intros [_ contra]; apply contra.
  - simpl; destruct (A_eq_dec q sink).
    right; intros [contra H]; contradiction.
    simpl; destruct (A_eq_dec (ixtransition a) q).
    + intuition.
    + destruct IH.
      * intuition.
      * right; intros [H1 contra]; destruct contra.
        2: assert (q <> sink /\ verify_tangible' q l').
        2: intuition.
        1,2: contradiction.
Qed.

(* Finally! *)
Theorem tangible_dec : forall q,
  {is_tangible q} + {~ is_tangible q}.
Proof.
  intro q;
  destruct (verify_tangible_dec q) as [H0|H0].
  - left; apply verify_tangible_correct; auto.
  - right; intro H; apply verify_tangible_correct in H; intuition.
Qed.

End TangibleDecidable.

End DFAUtils.